package UDPReceiverPackage;

import java.util.Arrays;

public class IntegrityCheck {

	// IntegrityCheck class adds cryptographic authentication to the application
	// RC4 algorithm is implemented by this class and the encrypted byte stream
	// is compressed to four bytes

	// ----------------------------fields---------------------//

	// static fields
	// the secret key byte array - can be from 1 to 256 bytes long
	private static byte[] key;
	// the length of the key
	private static int keyLength;
	// 256 byte state vector
	private static byte[] stateVector = new byte[256];
	// 256 byte temporary vector
	private static byte[] tempVector = new byte[256];
	// the counters used for stream generation
	private static int streamGenCounter1, streamGenCounter2;
	// the key stream generated by the algorithm
	private static byte[] keyStream;
	// the above fields are made static to maintain the state of the vectors and
	// key stream across different instances

	// instance fields
	// the four byte compressed form of the encrypted data
	private byte[] compressedOut = new byte[4];
	// the data or byte sequence that needs to be encrypted
	private byte[] data;

	// -------------public methods----------//
	// instance methods - constructor
	public IntegrityCheck(byte[] aData) {
		data = aData;
	}

	// instance methods -accessor
	public byte[] getIntegrityCheck() {
		computeIntegrity();
		return compressedOut;
	}

	// instance methods - mutators
	public void setKey(byte[] aKey) {
		key = aKey;
		keyLength = aKey.length;
	}

	public void setData(byte[] aData) {
		data = aData;
	}

	// static method
	public static void initialize(byte[] aKey) {
		// initializes and forms the initial permutation of the state and temp
		// vector using the secret key
		key = aKey;
		keyLength = aKey.length;

		// initialization of S and T vectors
		for (int i = 0; i <= 255; i++) {
			// S vector takes values from 0 to 255 in ascending order
			stateVector[i] = (byte) i;
			// K is repeatedly copied to T vector until T fills out
			tempVector[i] = key[i % keyLength];
		}

		// initial permutation of S vector
		int j = 0;
		for (int i = 0; i <= 255; i++) {
			// swapping elements of S according to scheme dictated by T
			// the byte values are bitwise and with 0xff to avoid negative
			// indices
			j = (j + (stateVector[i] & 0xff) + (tempVector[i] & 0xff)) % 256;
			byte temp = stateVector[j];
			stateVector[j] = stateVector[i];
			stateVector[i] = temp;
		}

		// initialize stream generation counters to zero
		streamGenCounter1 = 0;
		streamGenCounter2 = 0;

	}// initialize()

	public void computeKeyStream(int dataLength) {
		// stream generation
		// generates the key stream byte array of length equal to the data to
		// encrypt (along with zero padding)
		keyStream = new byte[dataLength];
		for (int i = 0; i < dataLength; i++) {
			// picking a keystream between 0 to 256 from S through a scheme
			// dictated by current permutation of S
			int temp;
			streamGenCounter1 = (streamGenCounter1 + 1) % 256;
			streamGenCounter2 = (streamGenCounter2 + (stateVector[streamGenCounter1] & 0xff)) % 256;
			// swapping
			byte tempByte = stateVector[streamGenCounter2];
			stateVector[streamGenCounter2] = stateVector[streamGenCounter1];
			stateVector[streamGenCounter1] = tempByte;
			temp = ((stateVector[streamGenCounter1] & 0xff) + (stateVector[streamGenCounter2] & 0xff)) % 256;
			keyStream[i] = stateVector[temp];
		}
	}// computeKeyStream()

	private void computeIntegrity() {
		byte[] dataToEncrypt;

		// Padding with zeroes if the length of data to encrypt is not a
		// multiple of 4
		if (data.length % 4 != 0) {
			// data length not a multiple of 4
			// no. of zeros to pad
			int noOfBytesToAdd = 4 - data.length % 4;
			// copying data to an array of longer length
			dataToEncrypt = new byte[data.length + noOfBytesToAdd];

			dataToEncrypt = Arrays.copyOf(data, data.length + noOfBytesToAdd);
			for (int i = data.length; i < dataToEncrypt.length; i++) {
				// padding zeroes
				dataToEncrypt[i] = 0x00;
			}
		} else {
			// no padding needed
			dataToEncrypt = new byte[data.length];
			dataToEncrypt = Arrays.copyOf(data, data.length);
		}

		// performing XOR of each byte of the data to encrypt with a keystream
		// byte from the stored keystream array
		byte[] encryptedData = new byte[dataToEncrypt.length];
		for (int i = 0; i < dataToEncrypt.length; i++) {
			encryptedData[i] = (byte) (dataToEncrypt[i] ^ keyStream[i]);
		}

		// compressing the encrypted data to 4 bytes by performing XOR
		for (int i = 0; i < compressedOut.length; i++) {
			compressedOut[i] = encryptedData[i];
			for (int j = 1; j < encryptedData.length / 4; j++) {
				compressedOut[i] ^= encryptedData[i + j * 4];
			}
		}
	}// computeIntegrity

}// class IntegrityCheck
